import React, { useState, useRef, useEffect, useMemo } from 'react'
import axios from 'axios'
import './rag-assistant-styles.css'

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000'

export default function RAGAssistant({ messages: conversationMessages, triggerMessage, ragScripts, setRagScripts }) {
  // const [scripts, setScripts] = useState([]) // Lifted to parent
  const [input, setInput] = useState('')
  const [loading, setLoading] = useState(false)
  const [history, setHistory] = useState([])
  const [selectedTag, setSelectedTag] = useState(null)
  const [expandedSources, setExpandedSources] = useState({})
  const [lastProcessedIndex, setLastProcessedIndex] = useState(-1)
  const scriptsEndRef = useRef(null)
  const scriptsContainerRef = useRef(null)
  const loadingRef = useRef(false)
  const messageQueueRef = useRef([])  // 메시지 큐
  const processingRef = useRef(false)  // 큐 처리 중 여부
  const historyRef = useRef([])  // 최신 history 참조용

  // 키워드 집계 (횟수별 내림차순 정렬)
  const keywords = useMemo(() => {
    if (!conversationMessages) return []
    const keywordCount = {}
    conversationMessages.forEach(msg => {
      if (msg.keywords && Array.isArray(msg.keywords)) {
        msg.keywords.forEach(kw => {
          if (kw && kw.trim()) {
            const normalized = kw.trim()
            keywordCount[normalized] = (keywordCount[normalized] || 0) + 1
          }
        })
      }
    })
    return Object.entries(keywordCount)
      .map(([keyword, count]) => ({ keyword, count }))
      .sort((a, b) => b.count - a.count)
  }, [conversationMessages])

  // history 변경 시 ref 업데이트
  useEffect(() => {
    historyRef.current = history
  }, [history])

  // 고객 메시지 클릭 시 스크립트 생성 (기본 UI 사용)
  useEffect(() => {
    if (triggerMessage?.content) {
      fetchScript(triggerMessage.content, { isAutoGenerated: true })
    }
  }, [triggerMessage])

  const scrollToBottom = () => {
    // 컨테이너를 직접 스크롤
    if (scriptsContainerRef.current) {
      scriptsContainerRef.current.scrollTo({
        top: scriptsContainerRef.current.scrollHeight,
        behavior: 'smooth'
      })
    }
  }

  useEffect(() => {
    // 약간의 딜레이 후 스크롤 (DOM 업데이트 완료 대기)
    const timer = setTimeout(() => {
      scrollToBottom()
    }, 100)
    return () => clearTimeout(timer)
  }, [ragScripts, loading])

  // 실시간 메시지 감지 - 고객 메시지가 오면 큐에 추가
  useEffect(() => {
    if (!conversationMessages || conversationMessages.length === 0) return

    // 처리되지 않은 모든 새 메시지를 큐에 추가
    for (let i = lastProcessedIndex + 1; i < conversationMessages.length; i++) {
      const msg = conversationMessages[i]
      if (msg.role === 'user') {
        messageQueueRef.current.push(msg.content)
      }
    }

    setLastProcessedIndex(conversationMessages.length - 1)

    // 큐 처리 시작
    processQueue()
  }, [conversationMessages])

  // 큐에서 메시지를 순차적으로 처리
  const processQueue = async () => {
    if (processingRef.current || messageQueueRef.current.length === 0) return

    processingRef.current = true
    setLoading(true)

    while (messageQueueRef.current.length > 0) {
      const query = messageQueueRef.current.shift()
      await autoFetchScript(query)
    }

    processingRef.current = false
    setLoading(false)
  }

  // 자동 스크립트 생성 함수 (실시간용)
  const autoFetchScript = async (query) => {
    if (!query.trim()) return

    try {
      const response = await axios.post(`${API_URL}/rag/chat`, {
        message: query,
        history: historyRef.current  // 최신 history 사용
      })

      if (response.data.skipped) {
        console.log(`⏭️ 자동 가이드 스킵: ${query}`)
        setHistory(response.data.history)
        historyRef.current = response.data.history
        return
      }

      const newScript = {
        id: Date.now(),
        title: query.length > 30 ? query.substring(0, 30) + '...' : query,
        content: response.data.answer,
        sources: deduplicateSources(response.data.sources || [], 2),
        isAutoGenerated: true
      }

      setRagScripts(prev => [...prev, newScript])
      setHistory(response.data.history)
      historyRef.current = response.data.history

    } catch (error) {
      console.error('Auto RAG Error:', error)
    }
  }

  // 태그 클릭 시 해당 키워드로 검색 (스킵 로직 무시)
  const handleTagClick = async (tag) => {
    if (loading) return

    setSelectedTag(tag.id)
    await fetchScript(tag.query, { forceGenerate: true })
  }

  // 스크립트 요청 (맥락 분석 포함)
  const fetchScript = async (query, options = {}) => {
    if (!query.trim() || loading) return

    setLoading(true)

    try {
      const response = await axios.post(`${API_URL}/rag/chat`, {
        message: query,
        history: history,
        force_generate: options.forceGenerate || false
      })

      // 맥락 분석 결과: SKIP된 경우 처리
      if (response.data.skipped) {
        console.log(`⏭️  가이드 생성 스킵: ${query} (이유: ${response.data.reason})`)
        // 히스토리만 업데이트, 화면에 표시하지 않음
        setHistory(response.data.history)
        return
      }

      // GENERATE된 경우: 정상적으로 스크립트 표시 (중복 페이지 제거, 최대 2개)
      const newScript = {
        id: Date.now(),
        title: query,
        content: response.data.answer,
        sources: deduplicateSources(response.data.sources || [], 2),
        reason: response.data.reason,
        isAutoGenerated: options.isAutoGenerated || false  // 기본 UI 사용 여부
      }

      setRagScripts(prev => [...prev, newScript])
      setHistory(response.data.history)

    } catch (error) {
      console.error('RAG Error:', error)
      const errorScript = {
        id: Date.now(),
        title: query,
        content: error.response?.status === 503
          ? 'RAG Agent가 실행 중이지 않습니다. 상담 가이드 기능을 사용할 수 없습니다.'
          : '죄송합니다. 현재 시스템 문제로 응답을 생성할 수 없습니다.',
        sources: [],
        isError: true
      }
      setRagScripts(prev => [...prev, errorScript])
    } finally {
      setLoading(false)
    }
  }

  const handleSend = async () => {
    if (!input.trim() || loading) return

    const query = input.trim()
    setInput('')
    await fetchScript(query)
  }

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSend()
    }
  }

  const clearScripts = () => {
    setRagScripts([])
    setHistory([])
    setSelectedTag(null)
    setExpandedSources({})
  }

  const toggleSource = (scriptId, sourceIdx) => {
    const key = `${scriptId}-${sourceIdx}`
    setExpandedSources(prev => ({
      ...prev,
      [key]: !prev[key]
    }))
  }

  // 중복 페이지 제거 및 최대 2개만 반환하는 헬퍼 함수
  const deduplicateSources = (sources, maxCount = 2) => {
    if (!sources || sources.length === 0) return []

    const seenPages = new Set()
    const uniqueSources = []

    for (const source of sources) {
      const pageKey = source.page || source.content?.substring(0, 50) // 페이지 번호 또는 내용 일부로 중복 체크
      if (!seenPages.has(pageKey)) {
        seenPages.add(pageKey)
        uniqueSources.push(source)
        if (uniqueSources.length >= maxCount) break
      }
    }

    return uniqueSources
  }

  // 키워드 클릭 시 매뉴얼만 검색
  const handleKeywordClick = async (keyword) => {
    if (loading) return

    setLoading(true)

    try {
      // 매뉴얼 검색 API 호출 (LLM 답변 생성 없이)
      const response = await axios.post(`${API_URL}/rag/search`, {
        query: keyword,
        k: 2 // 가장 관련도 높은 1~2개 매뉴얼만 가져오기
      })

      // 매뉴얼 검색 결과를 스크립트로 표시 (중복 페이지 제거, 최대 2개)
      const uniqueSources = deduplicateSources(response.data.sources || [], 2)
      const manualScript = {
        id: Date.now(),
        title: `"${keyword}" 관련 매뉴얼`,
        content: uniqueSources.map((s, idx) =>
          `[매뉴얼 ${s.page && s.page !== 'N/A' ? `p.${s.page}` : idx + 1}]\n${s.content}`
        ).join('\n\n') || '매뉴얼을 찾을 수 없습니다.',
        sources: uniqueSources,
        isManual: true
      }
      setRagScripts(prev => [...prev, manualScript])

    } catch (error) {
      console.error('Manual Search Error:', error)
      const errorScript = {
        id: Date.now(),
        title: `"${keyword}" 매뉴얼 검색`,
        content: error.response?.status === 503
          ? 'RAG Agent가 실행 중이지 않습니다. 매뉴얼 검색 기능을 사용할 수 없습니다.'
          : '매뉴얼 검색 중 오류가 발생했습니다.',
        sources: [],
        isError: true
      }
      setRagScripts(prev => [...prev, errorScript])
    } finally {
      setLoading(false)
    }
  }
  return (
    <div className="rag-container">
      {/* Header */}
      <div className="rag-header">
        <h2>AI 추천 스크립트</h2>
        {ragScripts.length > 0 && (
          <button className="clear-btn" onClick={clearScripts}>
            <span className="material-icons-outlined">refresh</span>
            초기화
          </button>
        )}
      </div>

      {/* Tag Chips - 실시간 키워드 */}
      <div className="tag-chips">
        {keywords.length === 0 ? (
          <span className="no-keywords">대화에서 키워드가 추출됩니다...</span>
        ) : (
          keywords.map((item, idx) => (
            <button
              key={`${item.keyword}-${idx}`}
              className={`tag-chip ${selectedTag === item.keyword ? 'active' : ''} ${loading ? 'loading' : ''}`}
              onClick={() => handleTagClick({ id: item.keyword, query: item.keyword })}
            >
              #{item.keyword}
              {item.count > 1 && <span className="keyword-count">{item.count}</span>}
            </button>
          ))
        )}
      </div>

      {/* Scripts List */}
      <div className="scripts-container" ref={scriptsContainerRef}>
        {ragScripts.length === 0 && !loading && (
          <div className="empty-scripts">
            <span className="material-icons-outlined">auto_awesome</span>
            <p><strong>실시간 상담 가이드</strong></p>
            <p>태그를 클릭하거나 질문을 입력하시면</p>
            <p>AI가 상담 스크립트를 추천해드립니다.</p>
          </div>
        )}

        {ragScripts.map((script, idx) => (
          <div
            key={script.id}
            className={`script-card ${!script.isAutoGenerated ? 'highlight' : ''} ${script.isError ? 'error' : ''} ${script.isManual ? 'manual' : ''}`}
          >
            <h3 className="script-title">
              {script.title}
            </h3>
            <p className="script-content">{script.content}</p>

            <div className="script-footer">
              {script.sources && script.sources.length > 0 && (
                <div className="source-links">
                  {script.sources.map((source, sourceIdx) => {
                    const key = `${script.id}-${sourceIdx}`
                    const isExpanded = expandedSources[key]

                    return (
                      <div key={sourceIdx} className="source-item">
                        <button
                          className="source-link"
                          onClick={() => toggleSource(script.id, sourceIdx)}
                        >
                          <span>
                            {source.page && source.page !== 'N/A'
                              ? `매뉴얼 p.${source.page}`
                              : '참조 문서'}
                          </span>
                          <span className="material-icons-outlined expand-icon">
                            {isExpanded ? 'expand_less' : 'expand_more'}
                          </span>
                        </button>

                        {isExpanded && (
                          <div className="source-content">
                            {source.content}
                          </div>
                        )}
                      </div>
                    )
                  })}
                </div>
              )}
            </div>
          </div>
        ))}

        {loading && (
          <div className="script-card loading">
            <div className="loading-content">
              <div className="loader"></div>
              <span>스크립트 생성 중...</span>
            </div>
          </div>
        )}

        <div ref={scriptsEndRef} />
      </div>

    </div>
  )
}
