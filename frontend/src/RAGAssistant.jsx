import React, { useState, useRef, useEffect, useMemo } from 'react'
import axios from 'axios'
import './rag-assistant-styles.css'

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000'

export default function RAGAssistant({ messages: conversationMessages, triggerMessage, ragScripts, setRagScripts, onClear }) {
  const [input, setInput] = useState('')
  const [loading, setLoading] = useState(false)
  const [history, setHistory] = useState([])
  const [selectedTag, setSelectedTag] = useState(null)
  const [expandedSources, setExpandedSources] = useState({})
  const [keywordsExpanded, setKeywordsExpanded] = useState(false) // 키워드 영역 펼침 여부
  const scriptsEndRef = useRef(null)
  const scriptsContainerRef = useRef(null)
  // 마지막으로 처리한 RAG 결과 ID (중복 방지용)
  const [lastRagResultId, setLastRagResultId] = useState(null)

  // 키워드 집계 (횟수별 내림차순 정렬)
  const keywords = useMemo(() => {
    if (!conversationMessages) return []
    const keywordCount = {}
    conversationMessages.forEach(msg => {
      if (msg.keywords && Array.isArray(msg.keywords)) {
        msg.keywords.forEach(kw => {
          if (kw && kw.trim()) {
            const normalized = kw.trim()
            keywordCount[normalized] = (keywordCount[normalized] || 0) + 1
          }
        })
      }
    })
    return Object.entries(keywordCount)
      .map(([keyword, count]) => ({ keyword, count }))
      .sort((a, b) => b.count - a.count)
  }, [conversationMessages])

  // 고객 메시지 클릭 시 스크립트 생성 (수동 호출)
  useEffect(() => {
    if (triggerMessage?.content) {
      fetchScript(triggerMessage.content, { isAutoGenerated: true })
    }
  }, [triggerMessage])

  // Backend에서 Push된 RAG 결과의 매뉴얼을 기본 열림 상태로 설정
  useEffect(() => {
    if (!ragScripts || ragScripts.length === 0) return
    
    // 새로 추가된 스크립트의 매뉴얼을 자동으로 열림 상태로 설정
    const newExpandedSources = {}
    ragScripts.forEach(script => {
      if (script.sources && script.sources.length > 0) {
        const key = `${script.id}-0`
        if (expandedSources[key] === undefined) {
          newExpandedSources[key] = true
        }
      }
    })
    
    if (Object.keys(newExpandedSources).length > 0) {
      setExpandedSources(prev => ({ ...prev, ...newExpandedSources }))
    }
  }, [ragScripts])

  const scrollToBottom = () => {
    // 컨테이너를 직접 스크롤
    if (scriptsContainerRef.current) {
      scriptsContainerRef.current.scrollTo({
        top: scriptsContainerRef.current.scrollHeight,
        behavior: 'smooth'
      })
    }
  }

  useEffect(() => {
    // 약간의 딜레이 후 스크롤 (DOM 업데이트 완료 대기)
    const timer = setTimeout(() => {
      scrollToBottom()
    }, 100)
    return () => clearTimeout(timer)
  }, [ragScripts, loading])

  // 자동 스크립트 생성은 백엔드에서 처리됨 (Fire-and-Forget)
  // 프론트엔드는 polling으로 ragScripts만 받아서 표시

  // 태그 클릭 시 해당 키워드로 검색 (스킵 로직 무시)
  const handleTagClick = async (tag) => {
    if (loading) return

    setSelectedTag(tag.id)
    await fetchScript(tag.query, { forceGenerate: true })
  }

  // 스크립트 요청 (맥락 분석 포함)
  const fetchScript = async (query, options = {}) => {
    if (!query.trim() || loading) return

    setLoading(true)

    try {
      const response = await axios.post(`${API_URL}/rag/chat`, {
        message: query,
        history: history,
        force_generate: options.forceGenerate || false
      })

      // 맥락 분석 결과: SKIP된 경우 처리
      if (response.data.skipped) {
        console.log(`⏭️  가이드 생성 스킵: ${query} (이유: ${response.data.reason})`)
        // 히스토리만 업데이트, 화면에 표시하지 않음
        setHistory(response.data.history)
        return
      }

      // GENERATE된 경우: 정상적으로 스크립트 표시 (중복 페이지 제거, 최대 2개)
      const newScript = {
        id: Date.now(),
        title: query,
        content: response.data.answer,
        sources: deduplicateSources(response.data.sources || [], 1),
        reason: response.data.reason,
        isAutoGenerated: options.isAutoGenerated || false,  // 기본 UI 사용 여부
        isLocal: true  // 프론트엔드에서 생성된 스크립트 (폴링 시 보존용)
      }

      setRagScripts(prev => [...prev, newScript])
      setHistory(response.data.history)
      // 매뉴얼 기본 열림 상태로 설정
      if (newScript.sources && newScript.sources.length > 0) {
        setExpandedSources(prev => ({
          ...prev,
          [`${newScript.id}-0`]: true
        }))
      }

    } catch (error) {
      console.error('RAG Error:', error)
      const errorScript = {
        id: Date.now(),
        title: query,
        content: error.response?.status === 503
          ? 'RAG Agent가 실행 중이지 않습니다. 상담 가이드 기능을 사용할 수 없습니다.'
          : '죄송합니다. 현재 시스템 문제로 응답을 생성할 수 없습니다.',
        sources: [],
        isError: true,
        isLocal: true
      }
      setRagScripts(prev => [...prev, errorScript])
    } finally {
      setLoading(false)
    }
  }

  const handleSend = async () => {
    if (!input.trim() || loading) return

    const query = input.trim()
    setInput('')
    await fetchScript(query)
  }

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSend()
    }
  }

  const clearScripts = () => {
    setRagScripts([])
    setHistory([])
    setSelectedTag(null)
    setExpandedSources({})
    // 부모 컴포넌트의 messages도 초기화 (키워드 초기화)
    if (onClear) onClear()
  }

  const toggleSource = (scriptId, sourceIdx) => {
    const key = `${scriptId}-${sourceIdx}`
    setExpandedSources(prev => ({
      ...prev,
      [key]: !prev[key]
    }))
  }

  // 중복 페이지 제거 및 최대 2개만 반환하는 헬퍼 함수
  const deduplicateSources = (sources, maxCount = 2) => {
    if (!sources || sources.length === 0) return []

    const seenPages = new Set()
    const uniqueSources = []

    for (const source of sources) {
      const pageKey = source.page || source.content?.substring(0, 50) // 페이지 번호 또는 내용 일부로 중복 체크
      if (!seenPages.has(pageKey)) {
        seenPages.add(pageKey)
        uniqueSources.push(source)
        if (uniqueSources.length >= maxCount) break
      }
    }

    return uniqueSources
  }

  // 키워드 클릭 시 매뉴얼만 검색
  const handleKeywordClick = async (keyword) => {
    if (loading) return

    setLoading(true)

    try {
      // 매뉴얼 검색 API 호출 (LLM 답변 생성 없이)
      const response = await axios.post(`${API_URL}/rag/search`, {
        query: keyword,
        k: 2 // 가장 관련도 높은 1~2개 매뉴얼만 가져오기
      })

      // 매뉴얼 검색 결과를 스크립트로 표시 (중복 페이지 제거, 최대 1개)
      const uniqueSources = deduplicateSources(response.data.sources || [], 1)
      const manualScript = {
        id: Date.now(),
        title: `"${keyword}" 관련 매뉴얼`,
        content: uniqueSources.map((s, idx) =>
          `[매뉴얼 ${s.page && s.page !== 'N/A' ? `p.${s.page}` : idx + 1}]\n${s.content}`
        ).join('\n\n') || '매뉴얼을 찾을 수 없습니다.',
        sources: uniqueSources,
        isManual: true,
        isLocal: true  // 프론트엔드에서 생성된 스크립트 (폴링 시 보존용)
      }
      setRagScripts(prev => [...prev, manualScript])
      // 매뉴얼 기본 열림 상태로 설정
      if (uniqueSources.length > 0) {
        setExpandedSources(prev => ({
          ...prev,
          [`${manualScript.id}-0`]: true
        }))
      }

    } catch (error) {
      console.error('Manual Search Error:', error)
      const errorScript = {
        id: Date.now(),
        title: `"${keyword}" 매뉴얼 검색`,
        content: error.response?.status === 503
          ? 'RAG Agent가 실행 중이지 않습니다. 매뉴얼 검색 기능을 사용할 수 없습니다.'
          : '매뉴얼 검색 중 오류가 발생했습니다.',
        sources: [],
        isError: true,
        isLocal: true
      }
      setRagScripts(prev => [...prev, errorScript])
    } finally {
      setLoading(false)
    }
  }
  return (
    <div className="rag-container">
      {/* Header */}
      <div className="rag-header">
        <h2>AI 추천 스크립트</h2>
        {ragScripts.length > 0 && (
          <button className="clear-btn" onClick={clearScripts}>
            <span className="material-icons-outlined">refresh</span>
            초기화
          </button>
        )}
      </div>

      {/* Tag Chips - 실시간 키워드 */}
      <div className={`tag-chips-wrapper ${keywordsExpanded ? 'expanded' : 'collapsed'}`}>
        <div className="tag-chips">
          {keywords.length === 0 ? (
            <span className="no-keywords">대화에서 키워드가 추출됩니다...</span>
          ) : (
            keywords.map((item, idx) => (
              <button
                key={`${item.keyword}-${idx}`}
                className={`tag-chip ${selectedTag === item.keyword ? 'active' : ''} ${loading ? 'loading' : ''}`}
                onClick={() => handleTagClick({ id: item.keyword, query: item.keyword })}
              >
                #{item.keyword}
                {item.count > 1 && <span className="keyword-count">{item.count}</span>}
              </button>
            ))
          )}
        </div>
        {keywords.length > 3 && (
          <button 
            className="keywords-toggle-btn"
            onClick={() => setKeywordsExpanded(!keywordsExpanded)}
          >
            <span className="material-icons-outlined">
              {keywordsExpanded ? 'expand_less' : 'expand_more'}
            </span>
          </button>
        )}
      </div>

      {/* Scripts List */}
      <div className="scripts-container" ref={scriptsContainerRef}>
        {ragScripts.length === 0 && !loading && (
          <div className="empty-scripts">
            <span className="material-icons-outlined">auto_awesome</span>
            <p><strong>실시간 상담 가이드</strong></p>
            <p>태그를 클릭하거나 질문을 입력하시면</p>
            <p>AI가 상담 스크립트를 추천해드립니다.</p>
          </div>
        )}

        {ragScripts.map((script, idx) => (
          <div
            key={script.id}
            className={`script-card ${!script.isAutoGenerated ? 'highlight' : ''} ${script.isError ? 'error' : ''} ${script.isManual ? 'manual' : ''}`}
          >
            <h3 className="script-title">
              {script.title}
            </h3>
            <p className="script-content">{script.content}</p>

            {/* 매뉴얼 박스 - 항상 표시 */}
            {script.sources && script.sources.length > 0 && (
              <div className="manual-box">
                <div className="manual-header">
                  <span className="material-icons-outlined">menu_book</span>
                  <span>
                    {script.sources[0].page && script.sources[0].page !== 'N/A'
                      ? `매뉴얼 p.${script.sources[0].page}`
                      : '참조 문서'}
                  </span>
                </div>
                <div className="manual-content">
                  {script.sources[0].content}
                </div>
              </div>
            )}
          </div>
        ))}

        {loading && (
          <div className="script-card loading">
            <div className="loading-content">
              <div className="loader"></div>
              <span>스크립트 생성 중...</span>
            </div>
          </div>
        )}

        <div ref={scriptsEndRef} />
      </div>

    </div>
  )
}
